---
title: 04.3.1-Spring源码学习-IOC-资源装载-解析默认标签-<bean>
date: 2019-04-12
categories: 源码学习
tags: [Spring]
---

> 对应《Spring源码深度解析 第2版》P71 3.3 bean标签的解析和注册

回看 [资源装载-注册BeanDefinition](04.3-Spring源码学习-IOC-资源装载-注册BeanDefinition.md)，如果根节点或者子节点采用默认命名空间的话，则调用`parseDefaultElement()`方法，进行默认标签解析：

```java
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
   // 对 import 标签处理
   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
      importBeanDefinitionResource(ele);
   }
   // 对 alias 标签处理
   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
      processAliasRegistration(ele);
   }
   // 对 bean 标签处理
   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
      processBeanDefinition(ele, delegate);
   }
   // 对 嵌套的beans 标签处理
   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
      // recurse
      doRegisterBeanDefinitions(ele);
   }
}
```

在四种标签的解析中，bean标签的解析最为复杂：



## 认识 BeanDefinition

解析 bean 标签的过程其实就是构造一个 `BeanDefinition` 对象的过程。

`BeanDefinition`是一个接口，在 Spring 中存在三种实现：`RootBeanDefinition`、`ChildBeanDefinition`和`GerericBeanDefinition`。三种实现均继承了`AbstractBeanDefinition`。

**`BeanDefinition`是配置文件`<bean>`元素标签在容器中的内部表现形式。**`BeanDefinition`和`<bean>`中的属性是一一对应的。

父`<bean>`用`RootBeanDefinition`表示，子`<bean>`用`ChildBeanDefinition`表示，而没有父`<bean>`的`<bean>`就使用`RootBeanDefinition`。

![](/Users/enhao/Documents/projects/GitHub/source-learning/spring-framework/source_docs/images/BeanDefinition相关类图.png)



## bean标签的解析

首先从方法`processBeanDefinition`开始：

```java
// org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#processBeanDefinition
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
  // 委托 BeanDefinitionParserDelegate 的 parseBeanDefinitionElement 方法进行元素解析，返回 BeanDefinitionHolder 对象
  // BeanDefinitionHolder 对象中包含了元素的各个属性了，例如 class、name、id、alias。。。
  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
  if (bdHolder != null) {
    // 解析成功，若存在默认标签的字节点下再有自定义属性，还需要再次对自定义标签进行解析
    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
    try {
      // Register the final decorated instance.
      // 解析完成后，对 beanDefinition 进行注册，委托给 BeanDefinitionReaderUtils
      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
    }
    catch (BeanDefinitionStoreException ex) {
      getReaderContext().error("Failed to register bean definition with name '" +
                               bdHolder.getBeanName() + "'", ele, ex);
    }
    // Send registration event.
    // 发出响应事件，通知相关的监听器，已完成该 Bean 标签的解析。
    getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
  }
}
```

整个过程分为四步：

1. 首先，委托 `BeanDefinitionParserDelegate` 的 `parseBeanDefinitionElement` 方法**进行元素解析，返回` BeanDefinitionHolder`对象。**

   > [解析BeanDefinition](#解析BeanDefinition)

2. 若第一步解析成功，若存在默认标签的字节点下再有自定义属性，还需要再次对**自定义标签进行解析**。

   > [解析默认标签中的自定义标签元素](#解析默认标签中的自定义标签元素)

3. 解析完成后，对解析后的`BeanDefinitionHolder`进行`BeanDefinition`解析。

   > [注册解析的BeanDefinition](#注册解析的BeanDefinition)

4. 发出响应事件，通知相关的监听器，已完成该 Bean 标签的解析。

   > [通知监听器解析及注册完成](#通知监听器解析及注册完成)

### 解析BeanDefinition

解析 `BeanDefinition`委托给了`BeanDefinitionParserDelegate`类的`parseBeanDefinitionElement`方法处理：

```java
// org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element)
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
  return parseBeanDefinitionElement(ele, null);
}

public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
  // 获取 bean 标签的 id 属性的值
  String id = ele.getAttribute(ID_ATTRIBUTE);
  // 获取 bean 标签 name 属性的值
  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

  List<String> aliases = new ArrayList<>();
  // 如果name存在，则分割 name 属性的值，计算别名集合
  if (StringUtils.hasLength(nameAttr)) {
    String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
    aliases.addAll(Arrays.asList(nameArr));
  }

  // 默认将 id 作为 bean 的名称
  String beanName = id;
  // 如果 id 为空，并且别名(name属性)不为空，则取别名集合的第一个作为 bean 的名称
  if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
    beanName = aliases.remove(0);
    if (logger.isTraceEnabled()) {
      logger.trace("No XML 'id' specified - using '" + beanName +
                   "' as bean name and " + aliases + " as aliases");
    }
  }

  if (containingBean == null) {
    // 检查 bean 名称的唯一性
    checkNameUniqueness(beanName, aliases, ele);
  }

  // 解析其他属性，构造 AbstractBeanDefinition 对象
  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
  if (beanDefinition != null) {
    // 如果 bean 的名称为空
    if (!StringUtils.hasText(beanName)) {
      try {
        if (containingBean != null) {
          // // 生成唯一的 beanName
          beanName = BeanDefinitionReaderUtils.generateBeanName(
            beanDefinition, this.readerContext.getRegistry(), true);
        }
        else {
          // 生成唯一的 beanName
          beanName = this.readerContext.generateBeanName(beanDefinition);
          // Register an alias for the plain bean class name, if still possible,
          // if the generator returned the class name plus a suffix.
          // This is expected for Spring 1.2/2.0 backwards compatibility.
          String beanClassName = beanDefinition.getBeanClassName();
          if (beanClassName != null &&
              beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
              !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
            aliases.add(beanClassName);
          }
        }
        if (logger.isTraceEnabled()) {
          logger.trace("Neither XML 'id' nor 'name' specified - " +
                       "using generated bean name [" + beanName + "]");
        }
      }
      catch (Exception ex) {
        error(ex.getMessage(), ele);
        return null;
      }
    }
    String[] aliasesArray = StringUtils.toStringArray(aliases);
    // 创建 BeanDefinitionHolder 对象
    return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
  }

  return null;
}
```

该方法还没有对`bean`标签进行全面解析，只是在解析前做了些功能架构，包括：

1. 提取元素中的id以及name属性；

2. 检测`beanName`的唯一性。

3. 解析bean的属性，封装成`AbstractBeanDefinition`对象。

   > [解析BeanDefinition属性](#解析BeanDefinition属性)

4. 若解析成功，bean的名称为空，则生成一个唯一的`beanName`。

5. 根据所获取的信息（`beanName`、`aliases`、`beanDefinition`）构造`BeanDefinitionHolder `实例对象并返回。

> `beanName`的命名规则：
>
> - `beanName`默认为`id`。
> - 如果`id`为空，但是`aliases`不为空，则`beanName`为第一个元素。
> - 如果都为空，则生成一个唯一的`beanName`。

#### 解析BeanDefinition属性

调用`parseBeanDefinitionElement`方法，解析`BeanDefinition`属性，封装为`GenericBeanDefinition`对象返回。

```java
// org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element, java.lang.String, org.springframework.beans.factory.config.BeanDefinition)
public AbstractBeanDefinition parseBeanDefinitionElement(
      Element ele, String beanName, @Nullable BeanDefinition containingBean) {

   // parseState：一个 linkedList集合
   // 将 beanName 封装成一个 BeanEntry 对象，放在parseState集合的第一个元素
   this.parseState.push(new BeanEntry(beanName));

   // 解析 class 属性
   String className = null;
   if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
   }
   // 解析 parent 属性
   String parent = null;
   if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
      parent = ele.getAttribute(PARENT_ATTRIBUTE);
   }

   try {
      // 根据 class 和 parent 创建 GenericBeanDefinition 对象
      AbstractBeanDefinition bd = createBeanDefinition(className, parent);
      // 解析属性
      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
      // 提取 description
      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

      // 下面的一堆是解析 <bean>......</bean> 内部的子元素，
      // 解析出来以后的信息都放到 bd 的属性中

      // 解析元数据 <meta />
      parseMetaElements(ele, bd);
      // 解析 lookup-method 属性 <lookup-method />
      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
      // 解析 replaced-method 属性 <replaced-method />
      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

      // 解析构造函数参数 <constructor-arg />
      parseConstructorArgElements(ele, bd);
      // 解析 property 子元素 <property />
      parsePropertyElements(ele, bd);
      // 解析 qualifier 子元素 <qualifier />
      parseQualifierElements(ele, bd);

      bd.setResource(this.readerContext.getResource());
      bd.setSource(extractSource(ele));

      return bd;
   }
   catch (ClassNotFoundException ex) {
      error("Bean class [" + className + "] not found", ele, ex);
   }
   catch (NoClassDefFoundError err) {
      error("Class that bean class [" + className + "] depends on not found", ele, err);
   }
   catch (Throwable ex) {
      error("Unexpected failure during bean definition parsing", ele, ex);
   }
   finally {
      // 解析完成后，将元素从parseState集合中删除
      this.parseState.pop();
   }

   return null;
}
```

属性解析大致分为两步：

1. 先解析出 class 和 parent 属性，由此创建`GenericBeanDefinition`对象。

2. 然后，解析`bean`标签的各种属性和标签内部的子元素，都放入`GenericBeanDefinition`对象中。

   > 属性和子元素的解析参考《Spring源码深度解析 第2版》P50-64

3. 解析成功，返回`GenericBeanDefinition`对象。

### 解析默认标签中的自定义标签元素

TODO

### 注册解析的BeanDefinition

TODO

### 通知监听器解析及注册完成

TODO



## 参考资料

- 芋道源码 精尽 Spring 源码分析
- 《Spring源码深度解析 第2版》
---
title: 05.2-Spring源码学习-IOC-加载Bean-尝试从缓存中加载单例
date: 2019-04-16
categories: 源码学习
tags: [Spring]
---

> 加载Bean的第二步：
>
> ```java
> // 2. 尝试从缓存中或者实例工厂中加载单例bean
> // 单例在Spring的同一个容器中只会被创建一次，后续再获取Bean，就直接从单例缓存中获取了。
> // 因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，
> // 在Spring中创建bean的原则是不等bean创建完成就会将bean的ObjectFactory提早曝光加入到缓存中，
> // 一旦下一个bean创建时候需要依赖上一个bean则直接使用ObjectFactory
> // Eagerly check singleton cache for manually registered singletons.
> Object sharedInstance = getSingleton(beanName);
> // 从缓存/实例工厂中获取到单例bean
> if (sharedInstance != null && args == null) {
>   if (logger.isTraceEnabled()) {
>     if (isSingletonCurrentlyInCreation(beanName)) {
>       logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
>                    "' that is not fully initialized yet - a consequence of a circular reference");
>     }
>     else {
>       logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
>     }
>   }
>   // 从缓存中得到了bean的原始状态，则需要对bean进行实例化
>   // 例如：我们需要对工厂bean进行处理，得到的其实是工厂bean的初始状态，
>   // 但是我们真正需要的是工厂bean中定义的factory-method方法中返回的bean。
>   // getObjectForBeanInstance 方法就是完成这个工作的
>   bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
> }
> ```

单例在Spring的同一个容器中只会被创建一次，后续再获取Bean，就直接从单例缓存中获取了。

首先**尝试从缓存中加载，如果加载不成功，则尝试从`singletonFactories`中加载。**

> 因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，在Spring中创建bean的原则是不等bean创建完成就会将bean的`ObjectFactory`提早曝光加入到缓存中，一旦下一个bean创建时候需要依赖上一个bean则直接使用`ObjectFactory`。

> 关于循环依赖：TODO

从缓存中得到了bean的原始状态，则需要**对bean进行实例化**。缓存中记录的只是最原始的bean状态，并不一定是我们最终想要的bean。

例如：我们需要对工厂bean进行处理，得到的其实是工厂bean的初始状态，但是我们真正需要的是工厂bean中定义的factory-method方法中返回的bean。`getObjectForBeanInstance` 方法就是完成这个工作的。



## 尝试从缓存中加载单例bean

调用 `DefaultSingletonBeanRegistry#getSingleton(String beanName)` 方法，尝试从缓存中获取 Bean 。

```java
// org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String)
public Object getSingleton(String beanName) {
  // 第二个参数：allowEarlyReference 是否允许引用被提早创建（为了避免循环依赖）
  return getSingleton(beanName, true);
}


/**
	* key : beanName ; value : bean的实例
	*/
/** Cache of singleton objects: bean name to bean instance. */
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

/**
	* key : beanName ; value : 创建bean的工厂
	*/
/** Cache of singleton factories: bean name to ObjectFactory. */
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);

/**
	* key : beanName ; value :  bean的实例
	* 和 singletonObjects 不同之处：当一个单例bean被放入earlySingletonObjects后，那么当bean还在创建过程中，
	* 就可以通过getBean方法获取到了，其目的是用来检测循环引用。
	* earlySingletonObjects 中存放的bean实例不一定完整。
  */
/** Cache of early singleton objects: bean name to bean instance. */
private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);

protected Object getSingleton(String beanName, boolean allowEarlyReference) {
  // 从单例缓存中加载bean
  // singletonObjects : 单例缓存
  Object singletonObject = this.singletonObjects.get(beanName);
  // 缓存中不存在当前bean 并且 当前的bean正在创建
  if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
    synchronized (this.singletonObjects) {
      // 从提早曝光的缓存中获取
      singletonObject = this.earlySingletonObjects.get(beanName);
      // 提早曝光的缓存中没有 并且 允许提早创建
      if (singletonObject == null && allowEarlyReference) {
        // 从 singletonFactories 中获取对应的 ObjectFactory
        ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
        if (singletonFactory != null) {
          // 获得 bean
          singletonObject = singletonFactory.getObject();
          // 添加 bean 到 提早曝光的缓存 中
          this.earlySingletonObjects.put(beanName, singletonObject);
          // 从 singletonFactories 中移除对应的 ObjectFactory
          this.singletonFactories.remove(beanName);
        }
      }
    }
  }
  // 缓存中存在当前bean，直接返回
  // 或者，缓存中不存在当前bean，当前bean也没有正在创建，直接返回 null
  return singletonObject;
}
```

步骤：

1. 从 `singletonObjects` 中，获取 Bean 对象。
2. 若获取不到且当前 bean 正在创建中，则从 `earlySingletonObjects` 中获取 Bean 对象。
3. 若还获取不到且允许提前创建，则从 `singletonFactories` 中获取相应的 ObjectFactory 对象，然后则调用其 `ObjectFactory#getObject(String name)`方法，创建 Bean 对象。然后将其加入到 `earlySingletonObjects` ，然后从 `singletonFactories` 删除。

存储bean不同的map如下：

- `singletonObjects`：用于保存`beanName`和创建bean实例之间的关系。

- `singletonFactories`：用于保存`beanName`和创建bean工厂之间的关系。

- `earlySingletonObjects`：用于保存`beanName`和创建bean实例之间的关系。

  > 和`singletonObjects`不同：当一个单例bean被放入earlySingletonObjects后，那么当bean还在创建过程中，就可以通过getBean方法获取到了，其**目的是用来检测循环引用。**
  >
  > `earlySingletonObjects` 中存放的bean实例不一定完整。

## bean的实例化

从缓存中获取单例bean，若获取的bean不为空，且`args`为空，则调用`getObjectForBeanInstance`方法。

**因为我们从缓存中获取的 bean 是最原始的 Bean ，并不一定使我们最终想要的 Bean 。**

该方法的定义为获取给定 Bean 实例的对象（该对象要么是 bean 实例本身，要么就是 `FactoryBean` 创建的 Bean 对象），**该方法用于检测该bean是否是`FactoryBean`类型的bean，如果是，那么需要调用该bean对应的`FactoryBean`实例中的`getObject()`作为返回值。**

```java
// org.springframework.beans.factory.support.AbstractBeanFactory#getObjectForBeanInstance
protected Object getObjectForBeanInstance(
  Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {

  // 如果 name 以 & 开头，即工厂类引用
  // 工厂类引用 要么是 NullBean，要么是 FactoryBean
  // Don't let calling code try to dereference the factory if the bean isn't a factory.
  if (BeanFactoryUtils.isFactoryDereference(name)) {
    // 如果是 NullBean，则直接返回
    if (beanInstance instanceof NullBean) {
      return beanInstance;
    }
    // 如果 beanInstance 不是 FactoryBean 类型，则抛出异常
    if (!(beanInstance instanceof FactoryBean)) {
      throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());
    }
  }

  // 现在，beanInstance 要么是普通的bean，要么是 FactoryBean 类型的bean
  // Now we have the bean instance, which may be a normal bean or a FactoryBean.
  // If it's a FactoryBean, we use it to create a bean instance, unless the
  // caller actually wants a reference to the factory.
  // 如果不是FactoryBean，直接返回，不做处理
  // 如果是FactoryBean，并且name 以 & 开头，表示想要获取的是工厂实例而不是工厂的GetObject()方法对应的实例，直接返回
  // 这里可以看出，如果想获取工厂实例，name以&开头
  if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {
    return beanInstance;
  }

  Object object = null;
  // 若 BeanDefinition 为 null，则从缓存中加载 Bean 对象
  if (mbd == null) {
    object = getCachedObjectForFactoryBean(beanName);
  }
  // 若 object 依然为空，则可以确认，beanInstance 一定是 FactoryBean 。从而，使用 FactoryBean 获得 Bean 对象
  if (object == null) {
    // Return bean instance from factory.
    FactoryBean<?> factory = (FactoryBean<?>) beanInstance;
    // Caches object obtained from FactoryBean if it is a singleton.
    // 检测是否定义 beanName 的 BeanDefinition
    if (mbd == null && containsBeanDefinition(beanName)) {
      // 将存储 XML 配置文件的 GenericBeanDefinition 转换为 RootBeanDefinition，
      // 如果指定 BeanName 是子 Bean 的话同时会合并父类的相关属性
      mbd = getMergedLocalBeanDefinition(beanName);
    }
    // 是否是用户定义的，而不是应用程序本身定义的
    boolean synthetic = (mbd != null && mbd.isSynthetic());
    // 核心逻辑，使用 FactoryBean 获得 Bean 对象
    object = getObjectFromFactoryBean(factory, beanName, !synthetic);
  }
  return object;
}
```

实际上，`#getObjectForBeanInstance(...)` 方法的**重心**，就是使用 FactoryBean 对象，获得( 或者创建 )其 Bean 对象，即调用 `#getObjectFromFactoryBean(...)` 方法：

```java
// org.springframework.beans.factory.support.FactoryBeanRegistrySupport#getObjectFromFactoryBean
// 缓存 FactoryBean 创建的单例 Bean 对象的映射
private final Map<String, Object> factoryBeanObjectCache = new ConcurrentHashMap<>(16);

```





## 参考资料

- 芋道源码 精尽 Spring 源码分析
- 《Spring源码深度解析 第2版》